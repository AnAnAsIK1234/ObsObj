https://habr.com/ru/companies/jetinfosystems/articles/467745/

![[Pasted image 20250207135922.png]]
# Для чего

![[Pasted image 20250207140004.png]]

![[Pasted image 20250207140026.png]]
![[Pasted image 20250207140036.png]]

# Метрики качества кластеризации
![[Pasted image 20250207140112.png]]
![[Pasted image 20250207140120.png]]
![[Pasted image 20250207140131.png]]
![[Pasted image 20250207140144.png]]
# То есть хотим, чтобы расстояние между ближайшими классами было максимальным, а расстояние между объектами внутри кластеров минимальным

![[Pasted image 20250207140157.png]]

# Как выбрать число кластеров - хз, но вот что есть
![[Pasted image 20250207140317.png]]


![[Pasted image 20250207140355.png]]
# Какие есть методы
![[Pasted image 20250207141141.png]]
# K-means++ - то есть мы инициализируем центры распихав их как можно дальше друг от друга, по углам мб в дефолтном K-means.
# Как строится 
- Первый шаг: для каждого центра определяем объекты, которые ему принадлежат
- Второй шаг: двигаем для объектов кластера центр, чтобы он располагался как центр масс
- Повторяем поочерёдно оба шага.
![[Pasted image 20250207141212.png]]
![[Pasted image 20250207141557.png]]![[Pasted image 20250207141615.png]]
![[Pasted image 20250207141521.png]]

# Иерархический подход - сначала делим все объекты по рандомным кластерам и потом начинаем ближайшие постепенно склеивать на каждом шаге $C^j$. В итоге получим кластер $C^l$, содержащий все объекты. (На последней картинке показано как мы постепенно объединяем объекты)
![[Pasted image 20250207141818.png]]
![[Pasted image 20250207141859.png]]
![[Pasted image 20250207141923.png]]

